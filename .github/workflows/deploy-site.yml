name: Deploy Dr.Welnes to VPS

on:
  push:
    branches: ["master", "main"]
    paths-ignore:
      - "site/**"
      - "README.md"
      - ".vscode/**"
  workflow_dispatch:

concurrency:
  group: deploy-drwelnes
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: [self-hosted, linux, x64, vps]

    env:
      COMPOSE_FILE: /var/www/drwelnes/docker-compose.prod.yml
      APP_DIR: /var/www/drwelnes

    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true

      - name: Preflight checks
        run: |
          set -euo pipefail
          echo "=== Docker access ==="
          if ! docker info >/dev/null 2>&1; then
            echo "ERROR: Cannot access Docker. Add runner user to docker group and restart runner service."
            exit 1
          fi
          echo "Docker OK"
          echo "=== .env.production ==="
          if [ ! -f "${{ env.APP_DIR }}/.env.production" ]; then
            echo "ERROR: ${{ env.APP_DIR }}/.env.production not found on VPS"
            echo "Create it with required variables (DATABASE_URL, NEXTAUTH_SECRET, NEXTAUTH_URL)."
            exit 1
          fi
          echo ".env.production OK"

      - name: Skip if already deployed
        id: check_skip
        run: |
          set -euo pipefail
          DEPLOYED_SHA_FILE="${{ env.APP_DIR }}/.deployed_sha"
          if [ -f "$DEPLOYED_SHA_FILE" ]; then
            deployed=$(cat "$DEPLOYED_SHA_FILE")
            if [ "$deployed" = "${{ github.sha }}" ]; then
              echo "Already deployed commit ${{ github.sha }}; skipping."
              echo "skip=true" >> "$GITHUB_OUTPUT"
            else
              echo "skip=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Copy source to app dir
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          mkdir -p "${{ env.APP_DIR }}"
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='site' \
            --exclude='node_modules' \
            ./ "${{ env.APP_DIR }}/src/"

      - name: Copy production env file
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          # .env.production must exist on the VPS at $APP_DIR/.env.production
          if [ ! -f "${{ env.APP_DIR }}/.env.production" ]; then
            echo "ERROR: ${{ env.APP_DIR }}/.env.production not found on VPS"
            exit 1
          fi
          cp "${{ env.APP_DIR }}/.env.production" "${{ env.APP_DIR }}/src/.env.production"

      - name: Create docker-compose .env for PostgreSQL
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          ENV_FILE="${{ env.APP_DIR }}/src/.env"
          echo "Creating $ENV_FILE with PostgreSQL defaults..."
          echo "POSTGRES_USER=drwelnes" > "$ENV_FILE"
          echo "POSTGRES_PASSWORD=drwelnes" >> "$ENV_FILE"
          echo "POSTGRES_DB=drwelnes" >> "$ENV_FILE"
          echo "DATABASE_URL=postgresql://drwelnes:drwelnes@db:5432/drwelnes" >> "$ENV_FILE"
          echo "=== Created .env file ==="
          cat "$ENV_FILE"
          echo "=== .env file permissions ==="
          ls -la "$ENV_FILE"

      - name: Build and deploy Docker containers
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          cd "${{ env.APP_DIR }}/src"
          echo "=== Debug: compose file header (first 30 lines) ==="
          sed -n '1,30p' docker-compose.prod.yml
          echo "=== Debug: env files ==="
          ls -la .env .env.production 2>/dev/null || true
          COMPOSE="docker compose --env-file .env -f docker-compose.prod.yml"
          $COMPOSE build --no-cache
          $COMPOSE up -d --remove-orphans

      - name: Run database migrations
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          cd "${{ env.APP_DIR }}/src"
          # Wait for DB to be healthy, then run migrations
          echo "Waiting for database to be ready..."
          COMPOSE="docker compose --env-file .env -f docker-compose.prod.yml"
          timeout 60 bash -c 'until '"$COMPOSE"' exec -T db pg_isready -U ${POSTGRES_USER:-drwelnes} -d ${POSTGRES_DB:-drwelnes}; do sleep 2; done'
          echo "Running Prisma migrations..."
          $COMPOSE exec -T web npx prisma migrate deploy
          echo "Migrations completed."

      - name: Save deployed SHA
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          echo "${{ github.sha }}" > "${{ env.APP_DIR }}/.deployed_sha"

      - name: Healthcheck
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail

          echo "=== Docker containers status ==="
          cd "${{ env.APP_DIR }}/src"
          COMPOSE="docker compose --env-file .env -f docker-compose.prod.yml"
          $COMPOSE ps

          echo "=== Recent container logs (last 30 lines) ==="
          $COMPOSE logs --tail=30

          BASE_URL="https://drwelnes.ru"
          MAX_ATTEMPTS=30
          SLEEP_SECONDS=3

          check_url() {
            local name="$1"
            local url="$2"
            local expect_code="$3"

            echo "==> Checking ${name}: ${url} (expect ${expect_code})"
            local attempt=1
            while [ "$attempt" -le "$MAX_ATTEMPTS" ]; do
              http_code=$(curl -sS -L --max-time 15 -o /dev/null -w "%{http_code}" "$url" || echo "000")
              if [ "$http_code" = "$expect_code" ]; then
                echo "OK: ${name}"
                return 0
              else
                echo "Attempt ${attempt}/${MAX_ATTEMPTS}: got HTTP ${http_code}, expected ${expect_code}"
              fi
              attempt=$((attempt + 1))
              sleep "$SLEEP_SECONDS"
            done
            echo "FAIL: ${name} healthcheck did not pass"
            echo "=== Full container logs on failure ==="
            $COMPOSE logs
            return 1
          }

          check_url "Home" "${BASE_URL}/" "200"
          check_url "Login" "${BASE_URL}/login" "200"

      - name: Cleanup old Docker images
        if: always()
        run: docker image prune -f

      - name: Notify Telegram on failure
        if: failure()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
            echo "Telegram secrets not configured; skipping."
            exit 0
          fi
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          TEXT="❌ Deploy failed\nRepo: ${{ github.repository }}\nBranch: ${{ github.ref_name }}\nCommit: ${{ github.sha }}\nRun: ${RUN_URL}"
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            --data-urlencode "text=${TEXT}" \
            -d "disable_web_page_preview=true" \
            >/dev/null

      - name: Notify Telegram on success
        if: success()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
            echo "Telegram secrets not configured; skipping."
            exit 0
          fi
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          TEXT="✅ Deploy succeeded\nRepo: ${{ github.repository }}\nBranch: ${{ github.ref_name }}\nCommit: ${{ github.sha }}\nRun: ${RUN_URL}"
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            --data-urlencode "text=${TEXT}" \
            -d "disable_web_page_preview=true" \
            >/dev/null
