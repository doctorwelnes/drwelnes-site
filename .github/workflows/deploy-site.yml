name: Deploy Dr.Welnes to VPS

on:
  push:
    branches: ["master", "main"]
    paths-ignore:
      - "site/**"
      - "README.md"
      - ".vscode/**"
  workflow_dispatch:

concurrency:
  group: deploy-drwelnes
  cancel-in-progress: false

jobs:
  build-and-deploy:
    runs-on: [self-hosted, linux, x64, vps]

    env:
      COMPOSE_FILE: /var/www/drwelnes/docker-compose.prod.yml
      APP_DIR: /var/www/drwelnes

    defaults:
      run:
        shell: bash

    steps:
      - name: Checkout repository
        uses: actions/checkout@v4
        with:
          fetch-depth: 0
          clean: true

      - name: Preflight checks
        run: |
          set -euo pipefail
          echo "=== Docker access ==="
          if ! docker info >/dev/null 2>&1; then
            echo "ERROR: Cannot access Docker. Add runner user to docker group and restart runner service."
            exit 1
          fi
          echo "Docker OK"
          echo "=== .env.production ==="
          if [ ! -f "${{ env.APP_DIR }}/.env.production" ]; then
            echo "ERROR: ${{ env.APP_DIR }}/.env.production not found on VPS"
            echo "Create it with required variables (DATABASE_URL, NEXTAUTH_SECRET, NEXTAUTH_URL)."
            exit 1
          fi
          echo ".env.production OK"

      - name: Skip if already deployed
        id: check_skip
        run: |
          set -euo pipefail
          DEPLOYED_SHA_FILE="${{ env.APP_DIR }}/.deployed_sha"
          if [ -f "$DEPLOYED_SHA_FILE" ]; then
            deployed=$(cat "$DEPLOYED_SHA_FILE")
            if [ "$deployed" = "${{ github.sha }}" ]; then
              echo "Already deployed commit ${{ github.sha }}; skipping."
              echo "skip=true" >> "$GITHUB_OUTPUT"
            else
              echo "skip=false" >> "$GITHUB_OUTPUT"
            fi
          else
            echo "skip=false" >> "$GITHUB_OUTPUT"
          fi

      - name: Copy source to app dir
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          mkdir -p "${{ env.APP_DIR }}"
          rsync -avz --delete \
            --exclude='.git' \
            --exclude='site' \
            --exclude='node_modules' \
            ./ "${{ env.APP_DIR }}/src/"

      - name: Copy production env file
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          # .env.production must exist on the VPS at $APP_DIR/.env.production
          if [ ! -f "${{ env.APP_DIR }}/.env.production" ]; then
            echo "ERROR: ${{ env.APP_DIR }}/.env.production not found on VPS"
            exit 1
          fi
          cp "${{ env.APP_DIR }}/.env.production" "${{ env.APP_DIR }}/src/.env.production"

      - name: Create docker-compose .env for PostgreSQL
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          ENV_FILE="${{ env.APP_DIR }}/src/.env"
          echo "Creating $ENV_FILE with PostgreSQL defaults..."
          echo "POSTGRES_USER=drwelnes" > "$ENV_FILE"
          echo "POSTGRES_PASSWORD=drwelnes" >> "$ENV_FILE"
          echo "POSTGRES_DB=drwelnes" >> "$ENV_FILE"
          echo "DATABASE_URL=postgresql://drwelnes:drwelnes@db:5432/drwelnes" >> "$ENV_FILE"
          echo "=== Created .env file ==="
          cat "$ENV_FILE"
          echo "=== Debug: DATABASE_URL lines ==="
          (grep -n '^DATABASE_URL' "$ENV_FILE" || true)
          (grep -n '^DATABASE_URL' "${{ env.APP_DIR }}/src/.env.production" || true)
          echo "=== .env file permissions ==="
          ls -la "$ENV_FILE"

      - name: Build and deploy Docker containers
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          cd "${{ env.APP_DIR }}/src"
          echo "=== Debug: compose file header (first 30 lines) ==="
          sed -n '1,30p' docker-compose.prod.yml
          echo "=== Debug: env files ==="
          ls -la .env .env.production 2>/dev/null || true
          COMPOSE="docker compose --env-file .env -f docker-compose.prod.yml"
          $COMPOSE build
          $COMPOSE up -d --remove-orphans

      - name: Run database migrations
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          cd "${{ env.APP_DIR }}/src"
          COMPOSE="docker compose --env-file .env -f docker-compose.prod.yml"
          # Wait for DB to be healthy
          echo "Waiting for database to be ready..."
          timeout 60 bash -c 'until '"$COMPOSE"' exec -T db pg_isready -U ${POSTGRES_USER:-drwelnes} -d ${POSTGRES_DB:-drwelnes}; do sleep 2; done'
          # Run migrations via dedicated migrator container (builder stage = full node_modules)
          echo "Running Prisma migrations..."
          $COMPOSE --profile migration run --rm migrator
          echo "Migrations completed."

      - name: Configure Nginx
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          NGINX_CONF="/etc/nginx/sites-available/drwelnes"
          NGINX_LINK="/etc/nginx/sites-enabled/drwelnes"

          # Check if sudo is available without password
          if ! sudo -n true 2>/dev/null; then
            echo "⚠️ sudo not available — skipping Nginx config"
            echo "Please manually create: $NGINX_CONF"
            exit 0
          fi

          # Create config only if it doesn't exist
          if [ ! -f "$NGINX_CONF" ]; then
            echo "Creating Nginx config for drwelnes.ru..."
            printf '%s\n' \
              'server {' \
              '    listen 80;' \
              '    server_name drwelnes.ru www.drwelnes.ru;' \
              '    return 301 https://$server_name$request_uri;' \
              '}' \
              '' \
              'server {' \
              '    listen 443 ssl;' \
              '    http2 on;' \
              '    server_name drwelnes.ru www.drwelnes.ru;' \
              '' \
              '    ssl_certificate /etc/letsencrypt/live/drwelnes.ru/fullchain.pem;' \
              '    ssl_certificate_key /etc/letsencrypt/live/drwelnes.ru/privkey.pem;' \
              '    include /etc/letsencrypt/options-ssl-nginx.conf;' \
              '    ssl_dhparam /etc/letsencrypt/ssl-dhparams.pem;' \
              '' \
              '    client_max_body_size 10M;' \
              '' \
              '    location / {' \
              '        proxy_pass         http://127.0.0.1:3000;' \
              '        proxy_http_version 1.1;' \
              '        proxy_set_header   Upgrade $http_upgrade;' \
              '        proxy_set_header   Connection upgrade;' \
              '        proxy_set_header   Host $host;' \
              '        proxy_set_header   X-Real-IP $remote_addr;' \
              '        proxy_set_header   X-Forwarded-For $proxy_add_x_forwarded_for;' \
              '        proxy_set_header   X-Forwarded-Proto $scheme;' \
              '        proxy_cache_bypass $http_upgrade;' \
              '        proxy_read_timeout 90s;' \
              '    }' \
              '}' | sudo tee "$NGINX_CONF" > /dev/null
            sudo ln -sf "$NGINX_CONF" "$NGINX_LINK"
            echo "Nginx config created ✅"
          else
            echo "Nginx config already exists — skipping creation"
          fi

          sudo nginx -t && sudo nginx -s reload
          echo "Nginx reloaded ✅"

      - name: Save deployed SHA
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          echo "${{ github.sha }}" > "${{ env.APP_DIR }}/.deployed_sha"

      - name: Healthcheck
        if: steps.check_skip.outputs.skip != 'true'
        run: |
          set -euo pipefail
          cd "${{ env.APP_DIR }}/src"
          COMPOSE="docker compose --env-file .env -f docker-compose.prod.yml"

          echo "=== Docker containers status ==="
          $COMPOSE ps

          echo "=== Step 1: Direct Next.js check (localhost:3000) ==="
          for i in $(seq 1 15); do
            code=$(curl -sS --max-time 5 -o /tmp/nextjs_body.txt -w "%{http_code}" http://localhost:3000/ || echo "000")
            if [ "$code" = "200" ] || [ "$code" = "308" ] || [ "$code" = "307" ]; then
              echo "✅ Next.js responding: HTTP $code"
              break
            fi
            echo "Attempt $i/15: Next.js HTTP $code"
            if [ "$i" = "15" ]; then
              echo "❌ Next.js direct check failed. Response body:"
              cat /tmp/nextjs_body.txt || true
              echo "=== Container logs ==="
              $COMPOSE logs --tail=50 web
              echo "=== Nginx error log ==="
              sudo tail -30 /var/log/nginx/error.log 2>/dev/null || echo "no nginx log"
              exit 1
            fi
            sleep 3
          done

          echo "=== Step 2: Domain check (https://drwelnes.ru/) ==="
          BASE_URL="https://drwelnes.ru"
          MAX_ATTEMPTS=20
          SLEEP_SECONDS=3

          check_url() {
            local name="$1" url="$2" expect_code="$3"
            echo "==> Checking ${name}: ${url} (expect ${expect_code})"
            local attempt=1
            while [ "$attempt" -le "$MAX_ATTEMPTS" ]; do
              http_code=$(curl -sS -L --max-time 15 -o /tmp/domain_body.txt -w "%{http_code}" "$url" || echo "000")
              if [ "$http_code" = "$expect_code" ]; then
                echo "OK: ${name} — HTTP ${http_code}"
                return 0
              fi
              echo "Attempt ${attempt}/${MAX_ATTEMPTS}: HTTP ${http_code}"
              attempt=$((attempt + 1))
              sleep "$SLEEP_SECONDS"
            done
            echo "FAIL: ${name}"
            echo "Response body:"
            cat /tmp/domain_body.txt || true
            echo "=== Full container logs ==="
            $COMPOSE logs --tail=50
            echo "=== Nginx error log ==="
            sudo tail -30 /var/log/nginx/error.log 2>/dev/null || echo "no nginx log"
            return 1
          }

          check_url "Home" "${BASE_URL}/" "200"
          check_url "Login" "${BASE_URL}/login" "200"

      - name: Cleanup old Docker images
        if: always()
        run: docker image prune -f

      - name: Notify Telegram on failure
        if: failure()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
            echo "Telegram secrets not configured; skipping."
            exit 0
          fi
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          TEXT="❌ Deploy failed\nRepo: ${{ github.repository }}\nBranch: ${{ github.ref_name }}\nCommit: ${{ github.sha }}\nRun: ${RUN_URL}"
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            --data-urlencode "text=${TEXT}" \
            -d "disable_web_page_preview=true" \
            >/dev/null

      - name: Notify Telegram on success
        if: success()
        env:
          TELEGRAM_BOT_TOKEN: ${{ secrets.TELEGRAM_BOT_TOKEN }}
          TELEGRAM_CHAT_ID: ${{ secrets.TELEGRAM_CHAT_ID }}
        run: |
          set -euo pipefail
          if [ -z "${TELEGRAM_BOT_TOKEN:-}" ] || [ -z "${TELEGRAM_CHAT_ID:-}" ]; then
            echo "Telegram secrets not configured; skipping."
            exit 0
          fi
          RUN_URL="${{ github.server_url }}/${{ github.repository }}/actions/runs/${{ github.run_id }}"
          TEXT="✅ Deploy succeeded\nRepo: ${{ github.repository }}\nBranch: ${{ github.ref_name }}\nCommit: ${{ github.sha }}\nRun: ${RUN_URL}"
          curl -sS -X POST "https://api.telegram.org/bot${TELEGRAM_BOT_TOKEN}/sendMessage" \
            -d "chat_id=${TELEGRAM_CHAT_ID}" \
            --data-urlencode "text=${TEXT}" \
            -d "disable_web_page_preview=true" \
            >/dev/null
