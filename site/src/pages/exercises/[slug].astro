---
import { getCollection } from "astro:content";
import { toEmbedUrl } from "../../lib/video";
import SiteLayout from "../../layouts/SiteLayout.astro";

export async function getStaticPaths() {
  const items = await getCollection("exercises");
  return items.map((entry) => ({ params: { slug: entry.slug }, props: { entry } }));
}

const { entry } = Astro.props;
const { Content } = await entry.render();
---

<SiteLayout title={entry.data.title} active="exercises">
  <section class="card card--hero" data-animate style="--delay: 0.05s;">
    <h1 class="hero-title">{entry.data.title}</h1>
    {entry.data.description && (
      <p class="hero-subtitle">{entry.data.description}</p>
    )}
  </section>

  {entry.data.videoFile ? (
    <section class="card card--soft" data-animate style="--delay: 0.1s;">
      <div data-video-shell class="video-shell">
        <div data-video-backdrop aria-hidden="true" class="video-backdrop"></div>
        <video
          controls={false}
          playsinline
          preload="metadata"
          controlslist="nodownload"
          class="video-player"
          src={entry.data.videoFile}
          poster={entry.data.videoPoster}
          data-video-resume-key={"exercise:" + entry.slug}
        />

        <!-- Custom controls -->
        <div style="position: absolute; bottom: 0; left: 0; right: 0; z-index: 3; pointer-events: auto; background: linear-gradient(transparent, rgba(0,0,0,0.7)); padding: 12px; display: flex; align-items: center; gap: 10px;">
          <button
            type="button"
            data-video-play-pause
            style="background: none; border: none; color: white; cursor: pointer; font-size: 18px; padding: 4px;"
          >
            â–¶
          </button>

          <div style="flex: 1; height: 4px; background: rgba(255,255,255,0.3); border-radius: 2px; position: relative; cursor: pointer;" data-video-progress>
            <div data-video-progress-bar style="height: 100%; background: #ef4444; border-radius: 2px; width: 0%; transition: width 0.1s;"></div>
          </div>

          <span data-video-time style="color: white; font-size: 12px; min-width: 80px;">0:00 / 0:00</span>

          <button
            type="button"
            data-video-mute
            style="background: none; border: none; color: white; cursor: pointer; font-size: 16px; padding: 4px;"
          >
            ðŸ”Š
          </button>

          <select
            data-video-speed
            style="background: rgba(0,0,0,0.5); border: 1px solid rgba(255,255,255,0.3); color: white; padding: 2px 4px; border-radius: 4px; font-size: 12px; cursor: pointer;"
          >
            <option value="0.5">0.5x</option>
            <option value="0.75">0.75x</option>
            <option value="1" selected>1x</option>
            <option value="1.25">1.25x</option>
            <option value="1.5">1.5x</option>
            <option value="2">2x</option>
          </select>

          <button
            type="button"
            data-video-fullscreen
            style="background: none; border: none; color: white; cursor: pointer; font-size: 16px; padding: 4px;"
          >
            â›¶
          </button>
        </div>
      </div>
    </section>
  ) : (
    entry.data.videoUrl && (
      <section class="card card--soft" data-animate style="--delay: 0.1s;">
        <iframe
          width="100%"
          height="420"
          src={toEmbedUrl(entry.data.videoUrl)}
          title={entry.data.title}
          allow="accelerometer; autoplay; clipboard-write; encrypted-media; gyroscope; picture-in-picture"
          allowfullscreen
          class="video-embed"
        />
      </section>
    )
  )}

  <article class="article-card" data-animate style="--delay: 0.15s;">
    <Content />
  </article>

  <script slot="scripts">
      (() => {
        const video = document.querySelector('video[data-video-resume-key]');
        if (!video) return;

        const shell = video.closest('[data-video-shell]');
        const backdrop = shell ? shell.querySelector('[data-video-backdrop]') : null;
        
        // Custom controls elements
        const playPauseBtn = shell?.querySelector('[data-video-play-pause]');
        const progressBar = shell?.querySelector('[data-video-progress]');
        const progressBarFill = shell?.querySelector('[data-video-progress-bar]');
        const timeDisplay = shell?.querySelector('[data-video-time]');
        const muteBtn = shell?.querySelector('[data-video-mute]');
        const speedSelect = shell?.querySelector('[data-video-speed]');
        const fullscreenBtn = shell?.querySelector('[data-video-fullscreen]');

        const key = video.getAttribute('data-video-resume-key');
        if (!key) return;

        const tKey = `drw:video:time:${key}`;
        const rKey = `drw:video:rate:${key}`;

        const clamp = (n, min, max) => Math.max(min, Math.min(max, n));
        
        const formatTime = (seconds) => {
          const mins = Math.floor(seconds / 60);
          const secs = Math.floor(seconds % 60);
          return `${mins}:${secs.toString().padStart(2, '0')}`;
        };
        
        const updatePlayPauseButton = () => {
          if (playPauseBtn) {
            playPauseBtn.textContent = video.paused ? 'â–¶' : 'âšâš';
          }
        };
        
        const updateProgress = () => {
          if (progressBarFill && timeDisplay) {
            const percent = (video.currentTime / video.duration) * 100;
            progressBarFill.style.width = `${percent}%`;
            timeDisplay.textContent = `${formatTime(video.currentTime)} / ${formatTime(video.duration)}`;
          }
        };
        
        const updateMuteButton = () => {
          if (muteBtn) {
            muteBtn.textContent = video.muted ? 'ðŸ”‡' : 'ðŸ”Š';
          }
        };

        const readNumber = (k) => {
          try {
            const raw = localStorage.getItem(k);
            if (!raw) return null;
            const n = Number(raw);
            return Number.isFinite(n) ? n : null;
          } catch {
            return null;
          }
        };

        const writeNumber = (k, v) => {
          try {
            localStorage.setItem(k, String(v));
          } catch {
            // ignore
          }
        };

        const savedRate = readNumber(rKey);
        if (savedRate && speedSelect) {
          video.playbackRate = clamp(savedRate, 0.25, 4);
          speedSelect.value = String(savedRate);
        }

        const applySavedTime = () => {
          const saved = readNumber(tKey);
          if (!saved || !Number.isFinite(video.duration) || video.duration <= 0) return;
          const target = clamp(saved, 0, Math.max(0, video.duration - 1));
          if (target > 0) video.currentTime = target;
        };

        const applyOrientation = () => {
          const vw = video.videoWidth;
          const vh = video.videoHeight;
          if (!vw || !vh) return;

          const portrait = vh > vw;

          if (shell) {
            if (portrait) {
              shell.style.maxWidth = '460px';
              shell.style.margin = '0 auto';
            } else {
              shell.style.maxWidth = '';
              shell.style.margin = '';
            }
          }

          const poster = video.getAttribute('poster');
          if (backdrop && poster && portrait) {
            backdrop.style.backgroundImage = `url("${poster}")`;
            backdrop.style.display = 'block';
          } else if (backdrop) {
            backdrop.style.display = portrait ? 'block' : 'none';
            if (!poster) backdrop.style.backgroundImage = '';
          }
        };

        const setBackdropFromVideoFrame = () => {
          if (!backdrop) return;
          const poster = video.getAttribute('poster');
          if (poster) return;

          const vw = video.videoWidth;
          const vh = video.videoHeight;
          if (!vw || !vh) return;
          if (!(vh > vw)) return;

          try {
            const canvas = document.createElement('canvas');
            canvas.width = Math.max(1, Math.min(vw, 640));
            canvas.height = Math.max(1, Math.round((canvas.width * vh) / vw));

            const ctx = canvas.getContext('2d');
            if (!ctx) return;
            ctx.drawImage(video, 0, 0, canvas.width, canvas.height);

            const dataUrl = canvas.toDataURL('image/jpeg', 0.75);
            backdrop.style.backgroundImage = `url("${dataUrl}")`;
            backdrop.style.display = 'block';
          } catch {
            // ignore
          }
        };

        video.addEventListener('loadedmetadata', () => {
          applySavedTime();
          applyOrientation();

          if (video.readyState >= 2) {
            setBackdropFromVideoFrame();
          }
        });

        video.addEventListener('loadeddata', () => {
          setBackdropFromVideoFrame();
          updateProgress();
          updatePlayPauseButton();
          updateMuteButton();
        });
        
        // Custom controls event listeners
        if (playPauseBtn) {
          playPauseBtn.addEventListener('click', () => {
            if (video.paused) {
              video.play().catch(() => null);
            } else {
              video.pause();
            }
          });
        }
        
        if (progressBar) {
          progressBar.addEventListener('click', (e) => {
            const rect = progressBar.getBoundingClientRect();
            const percent = (e.clientX - rect.left) / rect.width;
            if (video.duration) {
              video.currentTime = percent * video.duration;
              saveTime();
            }
          });
        }
        
        if (muteBtn) {
          muteBtn.addEventListener('click', () => {
            video.muted = !video.muted;
          });
        }
        
        if (speedSelect) {
          speedSelect.addEventListener('change', () => {
            const rate = Number(speedSelect.value);
            if (Number.isFinite(rate)) {
              video.playbackRate = clamp(rate, 0.25, 4);
              saveRate();
            }
          });
        }
        
        if (fullscreenBtn) {
          fullscreenBtn.addEventListener('click', () => {
            if (document.fullscreenElement) {
              document.exitFullscreen?.().catch?.(() => null);
            } else {
              shell?.requestFullscreen?.().catch?.(() => null);
            }
          });
        }
        
        // Video event listeners for custom controls
        video.addEventListener('play', updatePlayPauseButton);
        video.addEventListener('pause', updatePlayPauseButton);
        video.addEventListener('timeupdate', updateProgress);
        video.addEventListener('loadedmetadata', () => {
          updateProgress();
          updateMuteButton();
        });
        video.addEventListener('volumechange', updateMuteButton);

        video.addEventListener('seeked', () => {
          setBackdropFromVideoFrame();
        });

        const saveTime = () => {
          if (!Number.isFinite(video.currentTime)) return;
          writeNumber(tKey, Math.floor(video.currentTime));
        };

        const saveRate = () => {
          writeNumber(rKey, video.playbackRate);
        };

        const interval = window.setInterval(saveTime, 2000);
        video.addEventListener('pause', saveTime);
        video.addEventListener('ended', () => writeNumber(tKey, 0));
        video.addEventListener('ratechange', saveRate);
        window.addEventListener('beforeunload', saveTime);

        const cleanup = () => {
          window.clearInterval(interval);
        };
        window.addEventListener('pagehide', cleanup);

        const isEditableTarget = (t) => {
          if (!t) return false;
          const el = t;
          const tag = (el.tagName || '').toLowerCase();
          return tag === 'input' || tag === 'textarea' || tag === 'select' || el.isContentEditable;
        };

        document.addEventListener('keydown', (e) => {
          if (e.defaultPrevented) return;
          if (isEditableTarget(e.target)) return;
          if (e.ctrlKey || e.metaKey || e.altKey) return;

          const k = e.key;

          if (k === ' ' || k === 'Spacebar') {
            e.preventDefault();
            if (video.paused) video.play().catch(() => null);
            else video.pause();
            return;
          }

          if (k === 'ArrowLeft') {
            e.preventDefault();
            video.currentTime = clamp(video.currentTime - 5, 0, Number.isFinite(video.duration) ? video.duration : video.currentTime);
            saveTime();
            return;
          }

          if (k === 'ArrowRight') {
            e.preventDefault();
            const max = Number.isFinite(video.duration) ? video.duration : video.currentTime + 5;
            video.currentTime = clamp(video.currentTime + 5, 0, max);
            saveTime();
            return;
          }

          if (k === 'm' || k === 'M') {
            e.preventDefault();
            video.muted = !video.muted;
            return;
          }

          if (k === 'f' || k === 'F') {
            e.preventDefault();
            const el = video.parentElement || video;
            if (document.fullscreenElement) {
              document.exitFullscreen?.().catch?.(() => null);
              return;
            }
            el.requestFullscreen?.().catch?.(() => null);
            return;
          }

          const rateByKey = {
            '0': 0.75,
            '1': 1,
            '2': 1.25,
            '3': 1.5,
            '4': 2,
          };
          if (k in rateByKey) {
            e.preventDefault();
            const nextRate = rateByKey[k];
            video.playbackRate = clamp(nextRate, 0.25, 4);
            saveRate();
          }
        });
      })();
  </script>
</SiteLayout>
